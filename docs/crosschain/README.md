# Cross-Chain SoulKey Gate Deployment Guide

This guide explains how to deploy the `CrossChainSoulKeyGate` contract across EVM chains and hook it into an off-chain relayer / frontend stack that produces zkSNARK proofs. The flow mirrors the multi-chain access workflow requested for Sei, Base, Arbitrum, Hyperliquid, and future chains (Polygon, Solana via bridge).

## Contract Overview

The [`CrossChainSoulKeyGate`](../../contracts/src/crosschain/CrossChainSoulKeyGate.sol) contract is responsible for:

- Tracking **allowed Merkle roots** for different communities or verification epochs.
- Delegating zk proof verification to an external verifier contract (e.g. Groth16 or Plonk verifier generated by `snarkjs`).
- Consuming **nullifiers** so a SoulKey proof cannot be reused on another chain.
- Granting local access (`grantAccess`) and cross-chain access (`grantAccessFromCrossChain`) while emitting structured events for indexers.

### Key Storage Layout

| Mapping | Purpose |
| ------- | ------- |
| `activeMerkleRoots` | List of Merkle roots that are trusted for verification. |
| `consumedNullifiers` | Tracks nullifiers that have been used, preventing replay. |
| `hasAccess` | Local permission cache that downstream vaults or keepers can check. |

Events include detailed metadata (nullifier, root, chain source) for cross-chain analytics.

## Deploying the Gate

Deploy the gate and zk verifier with Foundry or Hardhat. A sample Hardhat script is shown below, simply swap in the addresses for each target chain:

```ts
import { ethers } from "hardhat";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with", deployer.address);

  const Verifier = await ethers.getContractFactory("ZkMultiFactorProofVerifier");
  const verifier = await Verifier.deploy();
  await verifier.deployed();
  console.log("Verifier:", verifier.address);

  const Gate = await ethers.getContractFactory("CrossChainSoulKeyGate");
  const gate = await Gate.deploy(
    verifier.address,
    process.env.MESSAGE_TRANSMITTER!
  );
  await gate.deployed();
  console.log("SoulKey gate:", gate.address);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

Suggested transmitter addresses:

| Chain | Message Transmitter |
| ----- | ------------------- |
| Base | `0xBaseMessageTransmitter` |
| Arbitrum | `0xArbitrumMessageTransmitter` |
| Ethereum | `0xEthereumMessageTransmitter` |

For non-CCIP chains (Sei, Hyperliquid, Solana, Polygon) deploy lightweight relayers that sign the [`CrossChainAttestation`](../../contracts/src/crosschain/CrossChainSoulKeyGate.sol#L20-L23) payload and call `grantAccessFromCrossChain` on the destination chain.

## Managing Roots and Nullifiers

1. **Activate roots** when issuing new SoulSigil batches:
   ```solidity
   gate.setMerkleRootStatus(0xRoot, true);
   ```
2. **Optionally deactivate** old roots when the epoch ends:
   ```solidity
   gate.setMerkleRootStatus(0xRoot, false);
   ```
3. **Monitor `NullifierConsumed` events** across chains to ensure no proof reuse.

## Off-Chain Proof Submission

The gate expects:

- `proof`: zkSNARK proof bytes.
- `publicInputs`: uint256 array (root, signal hash, nullifier, etc.).
- `merkleRoot`: must exist in `activeMerkleRoots`.
- `nullifier`: gets locked after first use.

### Local (Same-Chain) Submission

Frontends can call `grantAccess` directly once the user signs their EVM transaction.

```ts
await gate.grantAccess(proof, publicInputs, merkleRoot, nullifier, userAddress);
```

### Cross-Chain Submission via Relayer

1. The originating chain produces the payload and attestation:
   ```ts
   const payload = ethers.AbiCoder.defaultAbiCoder().encode(
     [
       "tuple(address account, bytes proof, uint256[] publicInputs, bytes32 merkleRoot, bytes32 nullifier)"
     ],
     [payloadStruct]
   );

   const attestation = ethers.AbiCoder.defaultAbiCoder().encode(
     ["tuple(address account, bytes32 sourceChain)"],
     [{ account: userAddress, sourceChain: chainIdBytes32 }]
   );
   ```
2. The trusted relayer / CCIP router calls:
   ```ts
   await gate.grantAccessFromCrossChain(payload, attestation);
   ```

### Backend Helper (Base RPC example)

```ts
import { ethers } from "ethers";

export async function submitCrossChainProof({ proof, publicSignals }) {
  const provider = new ethers.providers.JsonRpcProvider("https://base-rpc.publicnode.com");
  const signer = new ethers.Wallet(process.env.RELAYER_PK!, provider);
  const gate = new ethers.Contract(
    process.env.GATE_ADDRESS!,
    [
      "function grantAccess(bytes, uint256[], bytes32, bytes32, address)",
      "function grantAccessFromCrossChain(bytes, bytes)"
    ],
    signer
  );

  const payload = ethers.AbiCoder.defaultAbiCoder().encode(
    ["tuple(address, bytes, uint256[], bytes32, bytes32)"],
    [{
      account: proof.account,
      proof: proof.bytes,
      publicInputs: publicSignals,
      merkleRoot: proof.root,
      nullifier: proof.nullifier
    }]
  );

  const attestation = ethers.AbiCoder.defaultAbiCoder().encode(
    ["tuple(address, bytes32)"],
    [{ account: proof.account, sourceChain: proof.sourceChain }]
  );

  const tx = await gate.grantAccessFromCrossChain(payload, attestation);
  return tx.wait();
}
```

## Testing Strategy

Run the Foundry test suite once `forge` is installed in your environment:

```bash
forge test --match-contract CrossChainSoulKeyGateTest
```

The test exercises:

- Local proof submission and nullifier tracking.
- Cross-chain submissions (payload + attestation).
- Replays, unknown roots, verifier failures, and transmitter mismatches.

## Next Steps

- Integrate CCIP (Sei â†’ Base/Arbitrum/Ethereum) by wiring the router as the `messageTransmitter`.
- Implement bridge adapters for Solana / Polygon until native CCIP support ships.
- Connect the frontend SoulSigil proof generator to call the helper functions above.
- Extend `publicInputs` encoding to include governance or Hyperliquid-specific data if needed.
